# জাভাস্ক্রিপ্ট পরিচিতি  
  
## জাভাস্ক্রিপ্ট কী?  
জাভাস্ক্রিপ্ট হলো একটি প্রোগ্রামিং ভাষা যা ওয়েবসাইটকে আরও ইন্টারঅ্যাকটিভ এবং গতিশীল করে তোলে।  
এটি ব্রাউজারে চলে এবং ক্লায়েন্ট-সাইড স্ক্রিপ্টিংয়ের জন্য ব্যবহৃত হয়।  
  
## পরিবেশ সেটআপ (ব্রাউজার, VS Code, Node.js)  
জাভাস্ক্রিপ্ট চালানোর জন্য নিচের জিনিসগুলো সেটআপ করতে হবে:  
- **ব্রাউজার**: Google Chrome, Firefox বা অন্য যে কোনো আধুনিক ব্রাউজার ব্যবহার করা যেতে পারে।  
- **VS Code**: কোড লেখার জন্য Visual Studio Code ইনস্টল করুন।  
- **Node.js**: জাভাস্ক্রিপ্ট চালানোর জন্য Node.js ইনস্টল করুন, যা ব্যাকএন্ডেও ব্যবহৃত হয়।  
  
## আপনার প্রথম জাভাস্ক্রিপ্ট প্রোগ্রাম  
একটি সহজ জাভাস্ক্রিপ্ট প্রোগ্রাম লিখতে হলে HTML ফাইলের মধ্যে `<script>` ট্যাগ ব্যবহার করা যায় অথবা একটি আলাদা `.js` ফাইল তৈরি করা যায়।  
  
**HTML ফাইলের মধ্যে:**  
```html
<!DOCTYPE html>  
<html lang="bn">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>My First JavaScript</title>  
</head>  
<body>  
    <h1>জাভাস্ক্রিপ্ট শেখা শুরু করি!</h1>  
    <script>  
        console.log("হ্যালো, জাভাস্ক্রিপ্ট!");  
        alert("হ্যালো, বিশ্ব!");  
    </script>  
</body>  
</html>  
```
আলাদা script.js ফাইল ব্যবহার করে:

```js
console.log("হ্যালো, জাভাস্ক্রিপ্ট!");  
alert("হ্যালো, বিশ্ব!");  
```
এখন HTML ফাইলের মধ্যে এই স্ক্রিপ্ট ফাইল লিঙ্ক করতে হবে:
```html

<script src="script.js"></script>  
```
## উপসংহার
-এভাবেই আমরা আমাদের প্রথম জাভাস্ক্রিপ্ট প্রোগ্রাম চালাতে পারি।




# ভেরিয়েবল এবং কনস্ট্যান্ট  
  
## var, let, এবং const  
জাভাস্ক্রিপ্টে ভেরিয়েবল ডিক্লেয়ার করার জন্য তিনটি কীওয়ার্ড আছে: `var`, `let`, এবং `const`।  
  
- **var**: পুরোনো পদ্ধতি, ফাংশন-স্কোপড এবং রিডিক্লেয়ার করা যায়।  
- **let**: ব্লক-স্কোপড এবং রিডিক্লেয়ার করা যায় না, কিন্তু মান পরিবর্তন করা যায়।  
- **const**: ব্লক-স্কোপড এবং রিডিক্লেয়ার বা মান পরিবর্তন করা যায় না।  
  
**উদাহরণ:**  
```js
var name = "Rakib";  
let age = 23;  
const country = "Bangladesh";  
  
console.log(name, age, country);  
```
## ডাটা টাইপ
জাভাস্ক্রিপ্টে প্রধানত সাতটি ডাটা টাইপ রয়েছে:
1. string – টেক্সট সংরক্ষণের জন্য ব্যবহৃত হয়।
2. number – সমস্ত ধরণের সংখ্যা (integer, float)।
3. boolean – true বা false মান রাখে।
4. null – খালি বা অনির্দিষ্ট মান বোঝায়।
5. undefined – ভেরিয়েবল ডিক্লেয়ার করা হয়েছে কিন্তু কোনো মান দেওয়া হয়নি।
6. symbol – ইউনিক এবং পরিবর্তনযোগ্য নয় এমন মান সংরক্ষণে ব্যবহৃত হয়।
7. bigint – বড় সংখ্যা সংরক্ষণ করতে ব্যবহৃত হয়।
উদাহরণ:
```js

let text = "Hello, World!"; // string  
let number = 42; // number  
let isJavaScriptFun = true; // boolean  
let emptyValue = null; // null  
let notAssigned; // undefined  
let uniqueID = Symbol("id"); // symbol  
let bigNumber = 9007199254740991n; // bigint  
  
console.log(typeof text);  
console.log(typeof number);  
console.log(typeof isJavaScriptFun);  
console.log(typeof emptyValue);  
console.log(typeof notAssigned);  
console.log(typeof uniqueID);  
console.log(typeof bigNumber); 

``` 
## উপসংহার
জাভাস্ক্রিপ্টে var, let, এবং const ব্যবহার করে ভেরিয়েবল ডিক্লেয়ার করা যায়।
বিভিন্ন ধরণের ডাটা টাইপ ব্যবহার করে ভিন্ন ভিন্ন মান সংরক্ষণ করা সম্ভব।




# অপারেটরস  
  
## অ্যারিথমেটিক অপারেটরস (Arithmetic Operators)  
জাভাস্ক্রিপ্টে অ্যারিথমেটিক অপারেটর ব্যবহার করে গাণিতিক গণনা করা যায়।  
  
**অপারেটর তালিকা:**  
- `+` (যোগ)  
- `-` (বিয়োগ)  
- `*` (গুণ)  
- `/` (ভাগ)  
- `%` (মডুলাস - ভাগশেষ)  
- `**` (এক্সপোনেনশিয়েশন)  
- `++` (ইনক্রিমেন্ট)  
- `--` (ডিক্রিমেন্ট)  
  
**উদাহরণ:**  
```js
let a = 10, b = 3;  
console.log(a + b); // 13  
console.log(a - b); // 7  
console.log(a * b); // 30  
console.log(a / b); // 3.33  
console.log(a % b); // 1  
console.log(a ** b); // 1000  
a++;  
console.log(a); // 11  
b--;  
console.log(b); // 2  
```
## অ্যাসাইনমেন্ট অপারেটরস (Assignment Operators)
অ্যাসাইনমেন্ট অপারেটর ব্যবহার করে ভেরিয়েবলের মান সেট বা পরিবর্তন করা হয়।
অপারেটর তালিকা:
- = (মান অ্যাসাইন করা)
- += (যোগ করে অ্যাসাইন)
- -= (বিয়োগ করে অ্যাসাইন)
- *= (গুণ করে অ্যাসাইন)
- /= (ভাগ করে অ্যাসাইন)
- %= (মডুলাস করে অ্যাসাইন)
- **= (এক্সপোনেনশিয়েশন করে অ্যাসাইন)
উদাহরণ:
```js

let x = 5;  
x += 3; // x = x + 3  
console.log(x); // 8  
x -= 2;  
console.log(x); // 6  
x *= 4;  
console.log(x); // 24  
x /= 2;  
console.log(x); // 12  
x %= 5;  
console.log(x); // 2  
x **= 3;  
console.log(x); // 8  
```
## কম্পারিসন অপারেটরস (Comparison Operators)
কম্পারিসন অপারেটর দুটি মানের মধ্যে তুলনা করে এবং true বা false রিটার্ন করে।
অপারেটর তালিকা:
- == (সমান)
- === (কঠোরভাবে সমান)
- != (অসমান)
- !== (কঠোরভাবে অসমান)
- > (বড়)
- < (ছোট)
- >= (বড় বা সমান)
- <= (ছোট বা সমান)
উদাহরণ:
```js
console.log(5 == "5"); // true (টাইপ চেক করে না)  
console.log(5 === "5"); // false (টাইপ চেক করে)  
console.log(5 != "5"); // false  
console.log(5 !== "5"); // true  
console.log(10 > 5); // true  
console.log(10 < 5); // false  
console.log(10 >= 10); // true  
console.log(10 <= 9); // false  
```
## লজিক্যাল অপারেটরস (Logical Operators)
লজিক্যাল অপারেটর এক বা একাধিক শর্তের উপর ভিত্তি করে true বা false রিটার্ন করে।
অপারেটর তালিকা:
- && (AND - উভয় শর্ত true হলে true রিটার্ন করবে)
- || (OR - যেকোনো একটি শর্ত true হলে true রিটার্ন করবে)
- ! (NOT - বিপরীত মান রিটার্ন করবে)
উদাহরণ:
```js
let p = true, q = false;  
console.log(p && q); // false  
console.log(p || q); // true  
console.log(!p); // false  
```
## টার্নারি অপারেটর (Ternary Operator)
এটি শর্টকাট if-else অপারেটর যা তিনটি অংশে বিভক্ত:
condition ? trueValue : falseValue
উদাহরণ:
```js
let age = 20;  
let message = age >= 18 ? "প্রাপ্তবয়স্ক" : "অপ্রাপ্তবয়স্ক";  
console.log(message); // "প্রাপ্তবয়স্ক"  
```
## উপসংহার
- অ্যারিথমেটিক অপারেটর গাণিতিক হিসাবের জন্য ব্যবহৃত হয়।
- অ্যাসাইনমেন্ট অপারেটর মান সেট বা পরিবর্তন করতে ব্যবহৃত হয়।
- কম্পারিসন অপারেটর মানের তুলনা করতে ব্যবহৃত হয়।
- লজিক্যাল অপারেটর একাধিক শর্ত যাচাই করতে ব্যবহৃত হয়।
- টার্নারি অপারেটর সংক্ষিপ্ত if-else হিসেবে কাজ করে।




# কন্ট্রোল ফ্লো (Control Flow)  
প্রোগ্রামের প্রবাহ নিয়ন্ত্রণ করার জন্য `if`, `else if`, `else`, এবং `switch` স্টেটমেন্ট ব্যবহার করা হয়।  
যখন একটি প্রোগ্রাম চলে, তখন একাধিক শর্তের ভিত্তিতে এটি বিভিন্ন সিদ্ধান্ত নিতে পারে।  
কন্ট্রোল ফ্লো স্টেটমেন্ট ব্যবহার করে আমরা এই শর্তগুলো চেক করতে পারি এবং প্রয়োজনীয় কোড চালাতে পারি।  

## `if`, `else if`, এবং `else`  
- `if` স্টেটমেন্ট ব্যবহার করে নির্দিষ্ট শর্ত সত্য কিনা তা পরীক্ষা করা হয়।  
- `else if` অতিরিক্ত শর্ত পরীক্ষা করতে ব্যবহৃত হয়, যদি আগের `if` শর্ত মিথ্যা হয়।  
- `else` তখনই চলবে যখন আগের সব শর্ত মিথ্যা হবে, অর্থাৎ কোনো শর্তই সত্য হলো না।  

**উদাহরণ ১:** (সংখ্যা পজিটিভ, নেগেটিভ, বা শূন্য নির্ণয়)  
```js
let num = -5;  
if (num > 0) {  
  console.log("সংখ্যাটি পজিটিভ");  
} else if (num < 0) {  
  console.log("সংখ্যাটি নেগেটিভ");  
} else {  
  console.log("সংখ্যাটি শূন্য");  
}  
```
ব্যাখ্যা:
- এখানে num নামের একটি ভেরিয়েবল আছে যার মান -5।
- প্রথম if ব্লক চেক করবে, num > 0 কিনা। যেহেতু -5 পজিটিভ নয়, এটি মিথ্যা হবে।
- এরপর else if ব্লক চেক করবে, num < 0 কিনা। যেহেতু -5 নেগেটিভ সংখ্যা, এটি সত্য হবে এবং "সংখ্যাটি নেগেটিভ" প্রিন্ট হবে।
- else ব্লক এক্ষেত্রে চলবে না, কারণ আগের শর্ত সত্য হয়েছে।
উদাহরণ ২: (একজন ব্যবহারকারী প্রাপ্তবয়স্ক কিনা চেক করা)
```js
let age = 17;  
if (age >= 18) {  
  console.log("আপনি ভোট দিতে পারবেন");  
} else {  
  console.log("আপনি এখনও ভোট দেওয়ার যোগ্য নন");  
} 
```
ব্যাখ্যা:
- এখানে age চেক করা হচ্ছে। যদি বয়স 18 বা তার বেশি হয়, তাহলে "আপনি ভোট দিতে পারবেন" প্রিন্ট হবে।
- যদি বয়স 18 এর কম হয়, তাহলে else ব্লক চলবে এবং "আপনি এখনও ভোট দেওয়ার যোগ্য নন" দেখাবে।

## switch স্টেটমেন্ট
switch স্টেটমেন্ট ব্যবহার করে নির্দিষ্ট মানের উপর ভিত্তি করে বিভিন্ন কোড ব্লক চালানো যায়।
এটি তখন ব্যবহার করা হয় যখন অনেকগুলো if-else চেক করা কঠিন হয়ে যায়।
switch নির্দিষ্ট একটি মানের সাথে case গুলোর মান মেলানোর চেষ্টা করে।
গঠন:
```js
switch(expression) {  
  case value1:  
    // কোড  
    break;  
  case value2:  
    // কোড  
    break;  
  default:  
    // কোড  
}  
```
উদাহরণ ৩: (সপ্তাহের দিন চেক করা)
```js
let day = 3;  
let dayName;  
  
switch (day) {  
  case 1:  
    dayName = "রবিবার";  
    break;  
  case 2:  
    dayName = "সোমবার";  
    break;  
  case 3:  
    dayName = "মঙ্গলবার";  
    break;  
  case 4:  
    dayName = "বুধবার";  
    break;  
  case 5:  
    dayName = "বৃহস্পতিবার";  
    break;  
  case 6:  
    dayName = "শুক্রবার";  
    break;  
  case 7:  
    dayName = "শনিবার";  
    break;  
  default:  
    dayName = "ভুল ইনপুট";  
}  
  
console.log(dayName);  
```
ব্যাখ্যা:
- এখানে day নামের একটি ভেরিয়েবল আছে যার মান 3।
- switch ব্লকটি একে একে case গুলোর সাথে day এর মান মিলিয়ে দেখবে।
- case 3: এর মান day এর সমান, তাই এটি "মঙ্গলবার" সেট করবে এবং break স্টেটমেন্টের কারণে switch বন্ধ হয়ে যাবে।
- console.log(dayName); মঙ্গলবার প্রিন্ট করবে।
উদাহরণ ৪: (গ্রেড নির্ণয়)
```js
let grade = "B";  
  
switch (grade) {  
  case "A":  
    console.log("আপনার গ্রেড চমৎকার!");  
    break;  
  case "B":  
    console.log("আপনার গ্রেড ভালো!");  
    break;  
  case "C":  
    console.log("আপনার গ্রেড গড় মানের!");  
    break;  
  case "D":  
    console.log("আপনার গ্রেড উন্নতি প্রয়োজন!");  
    break;  
  case "F":  
    console.log("আপনি ফেল করেছেন!");  
    break;  
  default:  
    console.log("ভুল গ্রেড ইনপুট!");  
}  
```
ব্যাখ্যা:
- grade ভেরিয়েবলটির মান "B"।
- switch একে একে case গুলোর সাথে মিলিয়ে দেখবে।
- case "B": এর সাথে মিল পাওয়া গেলে "আপনার গ্রেড ভালো!" প্রিন্ট হবে।
- break থাকার কারণে switch ব্লক এখানেই বন্ধ হয়ে যাবে, পরবর্তী case গুলো আর চেক করা হবে না।
- যদি grade অন্য কিছু হতো যা কোনো case এর সাথে মেলেনি, তাহলে default অংশ চালু হতো।

## উপসংহার
- if-else শর্ত অনুযায়ী বিভিন্ন ব্লক চালানোর জন্য ব্যবহৃত হয়।
- switch স্টেটমেন্ট একাধিক সম্ভাব্য মানের সাথে মিলিয়ে কোড চালাতে ব্যবহৃত হয়।
- break ব্যবহার না করলে switch ব্লকের প্রতিটি case চালিয়ে যাবে, যা অনেক ক্ষেত্রে অনাকাঙ্ক্ষিত ফলাফল দিতে পারে।








# অ্যারে (Arrays)  
**অ্যারে হলো একটি ডাটা স্ট্রাকচার যেখানে একাধিক মান একত্রে সংরক্ষণ করা যায়।**  
এটি একটি তালিকা (list) আকারে কাজ করে এবং প্রতিটি উপাদান (element) একটি নির্দিষ্ট ইনডেক্সে (index) সংরক্ষিত থাকে।  

## কেন অ্যারে দরকার?  
- একাধিক ডাটা সংরক্ষণ ও পরিচালনার জন্য।  
- ডাটা গ্রুপ করে সহজে অ্যাক্সেস করা যায়।  
- লুপ বা অন্যান্য মেথড ব্যবহার করে সহজে ডাটা প্রসেস করা যায়।  

```js
// সাধারণ অ্যারে ঘোষণা  
let fruits = ["Apple", "Banana", "Mango"];  
console.log(fruits[0]); // "Apple"  
console.log(fruits[1]); // "Banana"  
console.log(fruits[2]); // "Mango"  
```
## গুরুত্বপূর্ণ অ্যারে মেথডসমূহ
### ১. push() → নতুন উপাদান অ্যাড করা (শেষে)
```js
let fruits = ["Apple", "Banana"];  
fruits.push("Mango");  
console.log(fruits); // ["Apple", "Banana", "Mango"]  
```
### ২. pop() → শেষ উপাদান রিমুভ করা
```js
let fruits = ["Apple", "Banana", "Mango"];  
fruits.pop();  
console.log(fruits); // ["Apple", "Banana"]  
```
### ৩. unshift() → নতুন উপাদান অ্যাড করা (শুরুর দিকে)
```js
let fruits = ["Banana", "Mango"];  
fruits.unshift("Apple");  
console.log(fruits); // ["Apple", "Banana", "Mango"]  
```
### ৪. shift() → প্রথম উপাদান রিমুভ করা
```js
let fruits = ["Apple", "Banana", "Mango"];  
fruits.shift();  
console.log(fruits); // ["Banana", "Mango"]  
```
### ৫. concat() → দুটি বা তার বেশি অ্যারে একত্রিত করা
```js
let arr1 = [1, 2];  
let arr2 = [3, 4];  
let result = arr1.concat(arr2);  
console.log(result); // [1, 2, 3, 4]  
```
### ৬. slice() → নির্দিষ্ট অংশ কপি করা
```js
let numbers = [10, 20, 30, 40, 50];  
let sliced = numbers.slice(1, 4);  
console.log(sliced); // [20, 30, 40]  
```
### ৭. splice() → নির্দিষ্ট ইনডেক্সে উপাদান যোগ/সরানো
```js
let numbers = [10, 20, 30, 40, 50];  
numbers.splice(2, 1, 99);  
console.log(numbers); // [10, 20, 99, 40, 50]  
```
### ৮. indexOf() → নির্দিষ্ট উপাদানের ইনডেক্স খুঁজে বের করা
```js
let fruits = ["Apple", "Banana", "Mango"];  
console.log(fruits.indexOf("Banana")); // 1  
```
### ৯. includes() → নির্দিষ্ট উপাদান আছে কিনা চেক করা
```js
let fruits = ["Apple", "Banana", "Mango"];  
console.log(fruits.includes("Banana")); // true  
console.log(fruits.includes("Orange")); // false 
``` 
### ১০. reverse() → অ্যারের উপাদান উল্টানো
```js
let numbers = [1, 2, 3, 4, 5];  
numbers.reverse();  
console.log(numbers); // [5, 4, 3, 2, 1] 
``` 
### ১১. sort() → উপাদান সাজানো
```js
let numbers = [30, 10, 50, 40, 20];  
numbers.sort((a, b) => a - b);  
console.log(numbers); // [10, 20, 30, 40, 50]  
```
## অ্যারে ইটারেশন মেথডসমূহ
### ১. forEach() → প্রতিটি উপাদান একবার করে এক্সেস করা
```js
let numbers = [10, 20, 30];  
numbers.forEach(num => console.log(num));  
// আউটপুট:  
// 10  
// 20  
// 30  
```
### ২. map() → প্রতিটি উপাদানে কিছু পরিবর্তন করে নতুন অ্যারে রিটার্ন করা
```js
let numbers = [1, 2, 3];  
let doubled = numbers.map(num => num * 2);  
console.log(doubled); // [2, 4, 6]  
```
### ৩. filter() → নির্দিষ্ট শর্ত অনুযায়ী উপাদান বাছাই করা
```js
let numbers = [10, 15, 20, 25, 30];  
let filtered = numbers.filter(num => num > 15);  
console.log(filtered); // [20, 25, 30]  
```
### ৪. reduce() → সব উপাদান যোগ করা বা নির্দিষ্ট ফলাফল তৈরি করা
```js
let numbers = [1, 2, 3, 4, 5];  
let sum = numbers.reduce((acc, num) => acc + num, 0);  
console.log(sum); // 15  
```
### ৫. find() → প্রথম যে উপাদান শর্ত পূরণ করবে তা রিটার্ন করা
```js
let numbers = [5, 10, 15, 20];  
let found = numbers.find(num => num > 10);  
console.log(found); // 15 
``` 
### ৬. findIndex() → প্রথম যে উপাদান শর্ত পূরণ করবে তার ইনডেক্স রিটার্ন করা
```js
let numbers = [5, 10, 15, 20];  
let index = numbers.findIndex(num => num > 10);  
console.log(index); // 2  
```
### ৭. every() → সব উপাদান শর্ত পূরণ করে কিনা চেক করা
```js
let numbers = [10, 20, 30];  
let result = numbers.every(num => num > 5);  
console.log(result); // true  
```
### ৮. some() → অন্তত একটি উপাদান শর্ত পূরণ করলে true রিটার্ন করা
```js
let numbers = [10, 20, 30];  
let result = numbers.some(num => num > 25);  
console.log(result); // true 
``` 
## উপসংহার
- অ্যারে ব্যবহার করলে ডাটা সংগ্রহ ও পরিচালনা সহজ হয়।
- অ্যারের গুরুত্বপূর্ণ মেথডগুলি ডাটা ম্যানিপুলেশনের জন্য অনেক কার্যকর।
- ইটারেশন মেথড যেমন map, filter, reduce ডাটা প্রসেসিংকে সহজ করে তোলে।



# অবজেক্টস (Objects)

## ১. অবজেক্ট লিটারালস (Object Literals)  
- অবজেক্ট হলো ডাটা সংগ্রহের একটি উপায় যা কী-ভ্যালু পেয়ার হিসেবে তথ্য ধারণ করে।  
- অবজেক্ট লিটারাল একটি নির্দিষ্ট অবজেক্ট তৈরি করার উপায়।
```js
let person = {  
  name: "Rakib",  
  age: 23,  
  country: "Bangladesh"  
};  
```
## ২. প্রপার্টি অ্যাক্সেস এবং পরিবর্তন (Accessing and Modifying Properties)
- অবজেক্টের প্রপার্টি অ্যাক্সেস করার জন্য ডট নোটেশন বা ব্র্যাকেট নোটেশন ব্যবহার করা হয়।
- প্রপার্টির মান পরিবর্তন করা খুবই সহজ।
```js
let person = {  
  name: "Rakib",  
  age: 23,  
  country: "Bangladesh"  
};  

// প্রপার্টি অ্যাক্সেস  
console.log(person.name);  // Rakib  
console.log(person["age"]);  // 23  

// প্রপার্টি পরিবর্তন  
person.age = 24;  
console.log(person.age);  // 24  
```
## ৩. অবজেক্ট মেথডস (Object Methods)
- অবজেক্টের মধ্যে ফাংশন থাকতে পারে, যা মেথড হিসেবে পরিচিত।
- মেথড অবজেক্টের কার্যকলাপ বা আচরণ নির্দেশ করে।
```js
let person = {  
  name: "Rakib",  
  age: 23,  
  greet: function() {  
    console.log("Hello, my name is " + this.name);  
  }  
};  

// মেথড কল করা  
person.greet();  // Hello, my name is Rakib  
```
## ৪. this কীওয়ার্ড (The this Keyword)
- this কীওয়ার্ড অবজেক্টের বর্তমান কনটেক্সট বা অবস্থা নির্দেশ করে।
- এটি মেথডের মধ্যে ব্যবহার করা হলে অবজেক্টকে রেফার করে।
```js
let person = {  
  name: "Rakib",  
  age: 23,  
  greet: function() {  
    console.log("Hello, my name is " + this.name);  
  }  
};  

person.greet();  // Hello, my name is Rakib  
```
## উপসংহার
- অবজেক্ট ডাটা স্টোর করতে সহায়ক এবং এটিতে প্রপার্টি ও মেথডস থাকতে পারে।
- অবজেক্ট লিটারাল, this কীওয়ার্ড, এবং মেথডস ওয়েব ডেভেলপমেন্টে কার্যকরী।





# লুপ (Loops)  
লুপ ব্যবহার করে কোডের নির্দিষ্ট অংশ বারবার চালানো যায়।  
জাভাস্ক্রিপ্টে পাঁচ ধরনের লুপ রয়েছে:  
- **for লুপ**  
- **while লুপ**  
- **do...while লুপ**  
- **for...in লুপ**  
- **for...of লুপ**  

## ১. `for` লুপ  
- `for` লুপ নির্দিষ্ট সংখ্যক বার চলতে পারে।  
- এটি তিনটি অংশ নিয়ে গঠিত:  
  1. **Initial Expression:** লুপ শুরু করার জন্য ভেরিয়েবল ইনিশিয়ালাইজ করা হয়।  
  2. **Condition:** শর্ত নির্ধারণ করা হয়, যা সত্য হলে লুপ চলবে।  
  3. **Increment/Decrement:** লুপ প্রতি চক্রের শেষে ভেরিয়েবলের মান পরিবর্তন করা হয়।  
```js
for (let i = 1; i <= 5; i++) {  
  console.log("Hello, JavaScript! " + i);  
}  
// আউটপুট:  
// Hello, JavaScript! 1  
// Hello, JavaScript! 2  
// Hello, JavaScript! 3  
// Hello, JavaScript! 4  
// Hello, JavaScript! 5  
```
ব্যাখ্যা:
- i ভেরিয়েবল ১ থেকে শুরু হয়।
- যতক্ষণ i <= 5, ততক্ষণ লুপ চলতে থাকবে।
- প্রতি চক্র শেষে i++ এর মান ১ করে বাড়বে।

## ২. while লুপ
- while লুপ ব্যবহার করা হয় যখন আমরা জানি না লুপ কতবার চলবে।
- এটি শুধুমাত্র শর্ত চেক করে, যতক্ষণ শর্ত সত্য থাকবে ততক্ষণ লুপ চলবে।
```js
let i = 1;  
while (i <= 5) {  
  console.log("Number: " + i);  
  i++;  
}  
// আউটপুট:  
// Number: 1  
// Number: 2  
// Number: 3  
// Number: 4  
// Number: 5  
```
ব্যাখ্যা:
- i ভেরিয়েবল ১ থেকে শুরু হয়।
- while লুপ চেক করবে i <= 5 হলে লুপ চলবে।
- প্রতিবার i++ বাড়ানো হয়, যতক্ষণ শর্ত সত্য থাকবে।

## ৩. do...while লুপ
- do...while লুপ প্রথমে কোড একবার চালায়, তারপর শর্ত চেক করে।
- শর্ত মিথ্যা হলেও কমপক্ষে একবার লুপ চলবেই।
```js
let i = 1;  
do {  
  console.log("Counting: " + i);  
  i++;  
} while (i <= 5);  
// আউটপুট:  
// Counting: 1  
// Counting: 2  
// Counting: 3  
// Counting: 4  
// Counting: 5  
```
ব্যাখ্যা:
- প্রথমে Counting: 1 প্রিন্ট হবে।
- তারপর শর্ত চেক করা হবে, যদি i <= 5 হয় তাহলে লুপ চলবে।
- while অংশে শর্ত মিথ্যা হলেও প্রথম do অংশ একবার চলবেই।

## ৪. for...in লুপ
- for...in লুপ অবজেক্টের সকল কী (key) অথবা ইনডেক্স (index) পুনরাবৃত্তি করতে ব্যবহৃত হয়।
```js
let person = { name: "Rakib", age: 23, country: "Bangladesh" };  
for (let key in person) {  
  console.log(key + ": " + person[key]);  
}  
// আউটপুট:  
// name: Rakib  
// age: 23  
// country: Bangladesh 
``` 
ব্যাখ্যা:
- for...in অবজেক্টের প্রতিটি কী-ভ্যালু জোড়া (key-value pair) অ্যাক্সেস করতে ব্যবহৃত হয়।
- person[key] এর মাধ্যমে সংশ্লিষ্ট ভ্যালু পাওয়া যায়।
## ৫. for...of লুপ
- for...of লুপ অ্যারে বা স্ট্রিং-এর মান পুনরাবৃত্তি করতে ব্যবহৃত হয়।
```js
let numbers = [10, 20, 30, 40, 50];  
for (let num of numbers) {  
  console.log(num);  
}  
// আউটপুট:  
// 10  
// 20  
// 30  
// 40  
// 50  
```
ব্যাখ্যা:
- for...of অ্যারের প্রতিটি এলিমেন্ট ধরে ধরে একবার করে চালায়।
- num ভেরিয়েবল প্রতিবার অ্যারের একটি নতুন ভ্যালু ধারণ করে।

## উপসংহার
- for লুপ নির্দিষ্ট সংখ্যা অনুযায়ী চলে।
- while লুপ শর্ত অনুযায়ী চলে যতক্ষণ তা সত্য থাকে।
- do...while লুপ কমপক্ষে একবার চালায়, তারপর শর্ত চেক করে।
- for...in অবজেক্টের key-value পেয়ার পুনরাবৃত্তি করতে ব্যবহৃত হয়।
- for...of অ্যারে ও স্ট্রিং-এর এলিমেন্ট পুনরাবৃত্তি করতে ব্যবহৃত হয়।









# ফাংশন (Functions)  
ফাংশন হলো কোডের পুনঃব্যবহারযোগ্য ব্লক যা নির্দিষ্ট একটি কাজ সম্পাদন করে।  
জাভাস্ক্রিপ্টে দুটি ধরনের ফাংশন রয়েছে:  
- **বিল্ট-ইন ফাংশন (Built-in Functions)**  
- **ইউজার-ডিফাইন্ড ফাংশন (Self-Made Functions)**  

## বিল্ট-ইন ফাংশন (Built-in Functions)  
জাভাস্ক্রিপ্টে অনেক বিল্ট-ইন ফাংশন রয়েছে, যা পূর্বনির্ধারিত কাজ সম্পাদন করে।  
উদাহরণস্বরূপ:  
```js
console.log("Hello World"); // আউটপুট: Hello World
let num = parseInt("10"); // স্ট্রিং থেকে নাম্বারে কনভার্ট করে
let squareRoot = Math.sqrt(16); // আউটপুট: 4
let randomNumber = Math.random(); // 0 থেকে 1 এর মধ্যে একটি র্যান্ডম সংখ্যা প্রদান করে
```
ব্যাখ্যা:
- console.log() স্ক্রিনে মেসেজ প্রিন্ট করতে ব্যবহৃত হয়।
- parseInt() একটি স্ট্রিংকে পূর্ণসংখ্যায় রূপান্তর করে।
- Math.sqrt() একটি সংখ্যার বর্গমূল প্রদান করে।
- Math.random() একটি এলোমেলো সংখ্যা তৈরি করে।

## ইউজার-ডিফাইন্ড ফাংশন (Self-Made Functions)
ব্যবহারকারী নিজে ফাংশন তৈরি করে নির্দিষ্ট কোনো কাজ সম্পাদন করতে পারে।
এই ফাংশনগুলো দুইভাবে ব্যবহার করা যায়:
- রিটার্ন ভ্যালু সহ (With return value)
- রিটার্ন ভ্যালু ছাড়া (Without return value)

## ৪ ধরনের ইউজার-ডিফাইন্ড ফাংশন:
### ১. রিটার্ন + প্যারামিটার (Return + Parameter)
- এই ফাংশনে প্যারামিটার গ্রহণ করা হয় এবং একটি মান রিটার্ন করা হয়।
- এটি সাধারণত গাণিতিক গণনা বা ডেটা প্রসেসিংয়ের জন্য ব্যবহৃত হয়।
```js
function add(a, b) {  
  return a + b;  
}  
let result = add(5, 10);  
console.log(result); // আউটপুট: 15  
```
ব্যাখ্যা:
- add(a, b) ফাংশন দুটি সংখ্যা গ্রহণ করে এবং তাদের যোগফল রিটার্ন করে।
- result ভেরিয়েবলে add(5, 10) এর মান সংরক্ষণ করা হয়।
- console.log(result) এটি প্রিন্ট করে।

### ২. রিটার্ন + কোন প্যারামিটার নেই (Return + No Parameter)
- এই ফাংশন কোনো প্যারামিটার গ্রহণ করে না তবে একটি মান রিটার্ন করে।
```js
function getCurrentYear() {  
  return new Date().getFullYear();  
}  
console.log(getCurrentYear()); // আউটপুট: বর্তমান বছর (যেমন 2025)  
```
ব্যাখ্যা:
- getCurrentYear() ফাংশন কোনো ইনপুট নেয় না, তবে বর্তমান বছর রিটার্ন করে।
- new Date().getFullYear() বর্তমান বছরের মান প্রদান করে।

### ৩. কোন রিটার্ন নেই + প্যারামিটার আছে (No Return + Parameter)
- এই ফাংশন প্যারামিটার গ্রহণ করে কিন্তু কোনো মান রিটার্ন করে না, শুধুমাত্র কাজ সম্পাদন করে।
```js
function greet(name) {  
  console.log("Hello, " + name + "!");  
}  
greet("Rakib"); // আউটপুট: Hello, Rakib!  
```
ব্যাখ্যা:
- greet(name) ফাংশন ব্যবহারকারীর নাম গ্রহণ করে এবং একটি মেসেজ প্রিন্ট করে।
- এটি কিছু রিটার্ন করে না, শুধুমাত্র console.log() ব্যবহার করে আউটপুট দেখায়।


### ৪. কোন রিটার্ন নেই + কোন প্যারামিটার নেই (No Return + No Parameter)
- এই ফাংশন কোনো ইনপুট নেয় না এবং কোনো মান রিটার্নও করে না, শুধুমাত্র কাজ সম্পাদন করে।
```js
function showMessage() {  
  console.log("Welcome to JavaScript!");  
}  
showMessage(); // আউটপুট: Welcome to JavaScript! 
``` 
ব্যাখ্যা:
- showMessage() ফাংশন কোনো ইনপুট নেয় না এবং কিছু রিটার্নও করে না।
- এটি শুধুমাত্র "Welcome to JavaScript!" মেসেজ প্রিন্ট করে।

## উপসংহার
- বিল্ট-ইন ফাংশন হলো পূর্বনির্ধারিত ফাংশন যা জাভাস্ক্রিপ্ট প্রদান করে।
- ইউজার-ডিফাইন্ড ফাংশন হলো ব্যবহারকারীর তৈরি ফাংশন যা নির্দিষ্ট কাজ সম্পাদন করতে ব্যবহৃত হয়।
- ফাংশন ৪টি প্রধান ধরণে বিভক্ত করা যায়:
1. রিটার্ন + প্যারামিটার আছে (ফাংশন ইনপুট নেয় এবং আউটপুট দেয়)।
2. রিটার্ন + প্যারামিটার নেই (ফাংশন কোনো ইনপুট নেয় না, কিন্তু আউটপুট দেয়)।
3. কোন রিটার্ন নেই + প্যারামিটার আছে (ফাংশন ইনপুট নেয় কিন্তু আউটপুট দেয় না, শুধুমাত্র কাজ করে)।
4. কোন রিটার্ন নেই + কোন প্যারামিটার নেই (ফাংশন কিছু ইনপুট নেয় না এবং কিছু রিটার্নও করে না, শুধুমাত্র কাজ করে)।






# DOM ম্যানিপুলেশন (DOM Manipulation)

## ১. এলিমেন্ট সিলেক্ট করা (Selecting Elements)  
- DOM (Document Object Model) হলো HTML ডকুমেন্টের অবজেক্ট মডেল, যার মাধ্যমে জাভাস্ক্রিপ্টের মাধ্যমে ওয়েব পেজের এলিমেন্ট এবং কনটেন্ট ম্যানিপুলেট করা যায়।  
- এলিমেন্ট সিলেক্ট করতে `getElementById()`, `querySelector()`, `getElementsByClassName()`, এবং অন্যান্য মেথড ব্যবহার করা হয়।
### ১.১ `getElementById()`  
- এই মেথডটি পেজের একটি নির্দিষ্ট ID-যুক্ত এলিমেন্ট সিলেক্ট করে।
```js
let element = document.getElementById("myElement");  
console.log(element);  // এইভাবে আপনার ID-যুক্ত এলিমেন্টটি সিলেক্ট হবে
```
### ১.২ querySelector()
- এই মেথডটি CSS সিলেক্টরের মতো এলিমেন্ট সিলেক্ট করে। এটি পেজে প্রথম মেলানো এলিমেন্টটি রিটার্ন করে।
```js
let element = document.querySelector(".myClass");  
console.log(element);  // এটি প্রথম `.myClass` ক্লাসযুক্ত এলিমেন্ট সিলেক্ট করবে
```
### ১.৩ getElementsByClassName()
- এই মেথডটি ক্লাস নামের মাধ্যমে একাধিক এলিমেন্ট সিলেক্ট করতে ব্যবহৃত হয়। এটি একটি HTMLCollection রিটার্ন করে।
```js
let elements = document.getElementsByClassName("myClass");  
console.log(elements);  // HTMLCollection রিটার্ন হবে
```
## ২. এলিমেন্ট মডিফাই করা (Modifying Elements)
- DOM ম্যানিপুলেশনের মাধ্যমে এলিমেন্টের টেক্সট, অ্যাট্রিবিউট এবং স্টাইল পরিবর্তন করা সম্ভব।

### ২.১ টেক্সট পরিবর্তন করা
- textContent বা innerText প্রপার্টি ব্যবহার করে এলিমেন্টের টেক্সট পরিবর্তন করা যায়।
```js
let element = document.getElementById("myElement");  
element.textContent = "নতুন টেক্সট";  
console.log(element.textContent);  // নতুন টেক্সট দেখাবে
```
### ২.২ অ্যাট্রিবিউট পরিবর্তন করা
- setAttribute() মেথড দিয়ে এলিমেন্টের অ্যাট্রিবিউট পরিবর্তন করা যায়।
```js
let imgElement = document.querySelector("img");  
imgElement.setAttribute("src", "newImage.jpg");  
console.log(imgElement.getAttribute("src"));  // newImage.jpg
```
### ২.৩ স্টাইল পরিবর্তন করা
- style প্রপার্টি ব্যবহার করে এলিমেন্টের CSS স্টাইল পরিবর্তন করা যায়।
```js
let element = document.getElementById("myElement");  
element.style.color = "red";  
element.style.fontSize = "20px";  
console.log(element.style.color);  // red
```
## ৩. ইভেন্ট লিসেনার (Event Listeners)
- DOM এলিমেন্টের সাথে ইন্টারঅ্যাকশন করতে ইভেন্ট লিসেনার ব্যবহার করা হয়। এটি বিভিন্ন ধরনের ইভেন্ট যেমন click, mouseover, keydown, ইত্যাদির জন্য ব্যবহার করা যায়।

### ৩.১ addEventListener()
- addEventListener() মেথড ব্যবহার করে একটি নির্দিষ্ট ইভেন্টের জন্য ফাংশন যুক্ত করা হয়।
```js
let button = document.getElementById("myButton");  
button.addEventListener("click", function() {  
  alert("বাটন ক্লিক করা হয়েছে!");  
});
```
### ৩.২ click ইভেন্ট
- click ইভেন্ট পেইজে এলিমেন্টে ক্লিক করার জন্য ব্যবহার করা হয়।
```js
let button = document.getElementById("myButton");  
button.addEventListener("click", function() {  
  console.log("আপনি বাটনটি ক্লিক করেছেন!");  
});
```
### ৩.৩ mouseover ইভেন্ট
- mouseover ইভেন্ট ব্যবহার করা হয় যখন মাউস পয়েন্টার একটি এলিমেন্টের উপর চলে আসে।
```js
let box = document.getElementById("myBox");  
box.addEventListener("mouseover", function() {  
  box.style.backgroundColor = "yellow";  
});
```
### ৩.৪ mouseout ইভেন্ট
- mouseout ইভেন্ট ব্যবহার করা হয় যখন মাউস পয়েন্টার এলিমেন্টের বাইরে চলে যায়।
```js
let box = document.getElementById("myBox");  
box.addEventListener("mouseout", function() {  
  box.style.backgroundColor = "white";  
});
```
## ১. API থেকে ডেটা লোড করা (Loading Data from an API)
- API থেকে ডেটা লোড করার জন্য `fetch()` বা `axios` ব্যবহার করা হয়। এগুলি HTTP রিকোয়েস্ট করে এবং সার্ভার থেকে ডেটা নিয়ে আসে।

### ১.১ `fetch()` মেথড ব্যবহার করে ডেটা লোড করা  
- `fetch()` হল ব্রাউজারের একটি বিল্ট-ইন ফাংশন যা HTTP রিকোয়েস্ট পাঠাতে ব্যবহৃত হয়। এটি প্রমিস রিটার্ন করে, যার মাধ্যমে ডেটা আসার পর কাজ করা যায়।
```js
fetch('https://jsonplaceholder.typicode.com/posts')  
  .then(response => response.json())  // JSON ফরম্যাটে রেসপন্স পাওয়া যাবে
  .then(data => {  
    console.log(data);  // ডেটা কনসোল লগে প্রিন্ট হবে
  })  
  .catch(error => console.log('Error:', error));  // যদি কোনো ত্রুটি ঘটে
```
## উপসংহার
- DOM ম্যানিপুলেশন ওয়েব ডেভেলপমেন্টের অত্যন্ত গুরুত্বপূর্ণ একটি অংশ, যা ব্যবহারকারীর ইন্টারঅ্যাকশন এবং পেজ কনটেন্ট পরিবর্তন করতে সাহায্য করে।
- এলিমেন্ট সিলেক্ট করা, মডিফাই করা এবং ইভেন্ট লিসেনার ব্যবহার করা দিয়ে সহজেই ইন্টারঅ্যাকটিভ ওয়েব পেজ তৈরি করা সম্ভব।
- fetch()` মেথড ব্যবহার করে ডেটা লোড করা





# ES6+ ফিচারস (ES6+ Features)

## ১. টেমপ্লেট লিটারালস (Template Literals)
- টেমপ্লেট লিটারালস (Template Literals) হলো একটি নতুন ফিচার যা ES6 এ সংযোজন করা হয়। এটি স্ট্রিং বানাতে সহজতর এবং আরও শক্তিশালী উপায় সরবরাহ করে। আপনি এটি ব্যবহার করে বহুমাত্রিক স্ট্রিং তৈরি করতে পারেন এবং বিভিন্ন এক্সপ্রেশন সরাসরি স্ট্রিংয়ের মধ্যে প্রবেশ করাতে পারেন।

### ১.১ সাধারণ স্ট্রিং তৈরি
- আগের জাভাস্ক্রিপ্ট সংস্করণে স্ট্রিং তৈরি করতে কনকাটেনেশন ব্যবহার করতে হত, যা কোডকে ভারী করে তুলত। কিন্তু টেমপ্লেট লিটারালস ব্যবহারে এই কাজ সহজ হয়ে যায়।
```js
let name = "Rakib";  
let greeting = "Hello, " + name + "!";  
console.log(greeting);  // Output: Hello, Rakib!
```
### ১.২ টেমপ্লেট লিটারালস ব্যবহার করে স্ট্রিং তৈরি
- টেমপ্লেট লিটারালস (`) ব্যবহার করলে স্ট্রিংয়ের মধ্যে এক্সপ্রেশনকে ${} দিয়ে প্রবেশ করানো যায়, এবং একাধিক লাইনে স্ট্রিং তৈরি করা সম্ভব।
```js
let name = "Rakib";  
let greeting = `Hello, ${name}! Welcome to our website.`;  
console.log(greeting);  // Output: Hello, Rakib! Welcome to our website.
```
### ১.৩ মাল্টি-লাইনে স্ট্রিং তৈরি
```js
let message = `This is a message
that spans multiple lines
without using any escape characters.`;  
console.log(message);
```
## ২. ডেসট্রাকচারিং (Destructuring)
- ডেসট্রাকচারিং হলো একটি প্রক্রিয়া যা আপনাকে অবজেক্ট বা অ্যারে থেকে ভ্যালু এক্সট্র্যাক্ট করে ভ্যারিয়েবল হিসাবে সেভ করতে সাহায্য করে। এটি কোডের পরিস্কার এবং সংক্ষিপ্ততা বজায় রাখতে সাহায্য করে।

### ২.১ অ্যারে ডেসট্রাকচারিং
- অ্যারে ডেসট্রাকচারিং আপনাকে অ্যারের নির্দিষ্ট উপাদানগুলো ভ্যারিয়েবলে সংরক্ষণ করতে সাহায্য করে।
```js
let fruits = ["apple", "banana", "cherry"];  
let [first, second] = fruits;  
console.log(first);  // Output: apple  
console.log(second); // Output: banana
```
### ২.২ অবজেক্ট ডেসট্রাকচারিং
- অবজেক্ট ডেসট্রাকচারিং আপনাকে অবজেক্টের প্রপার্টি সহজে ভ্যারিয়েবলে সংরক্ষণ করতে সাহায্য করে।
```js
let person = { name: "Rakib", age: 23 };  
let { name, age } = person;  
console.log(name);  // Output: Rakib  
console.log(age);   // Output: 23
```
### ২.৩ ডিফল্ট মান সেট করা
- আপনি ডেসট্রাকচারিংয়ের সময় ডিফল্ট মানও দিতে পারেন।
```js
let person = { name: "Rakib" };  
let { name, age = 25 } = person;  
console.log(name);  // Output: Rakib  
console.log(age);   // Output: 25 (default value)
```
## ৩. মডিউলস (Modules)
- ES6 মডিউল সিস্টেম (import/export) ব্যবহার করে কোডকে ভাগ করে লিখতে সাহায্য করে। এটি কোডকে আরো রিয়ুসেবল এবং মেইনটেনেবল করে তোলে।

### ৩.১ export ব্যবহার করে মডিউল রপ্তানি (Exporting a Module)
- export ব্যবহার করে ফাংশন, ক্লাস বা ভ্যারিয়েবলকে অন্য ফাইলে রপ্তানি (export) করা যায়।
```js
// file1.js  
export function greet(name) {  
  return `Hello, ${name}`;  
}
```
### ৩.২ import ব্যবহার করে মডিউল আমদানি (Importing a Module)
- import ব্যবহার করে অন্য ফাইল থেকে রপ্তানি করা ফাংশন, ক্লাস বা ভ্যারিয়েবল আমদানি (import) করা যায়।
```js
// file2.js  
import { greet } from './file1.js';  
console.log(greet("Rakib"));  // Output: Hello, Rakib
```
### ৩.৩ ডিফল্ট এক্সপোর্ট (Default Export)
- default এক্সপোর্ট ব্যবহার করে মডিউল থেকে একটি ডিফল্ট এক্সপোর্ট করা যায়।
```js
// file1.js  
export default function greet(name) {  
  return `Hello, ${name}`;  
}
```
```js
// file2.js  
import greet from './file1.js';  
console.log(greet("Rakib"));  // Output: Hello, Rakib
```







# ত্রুটি হ্যান্ডলিং (Error Handling)

## ১. `try`, `catch`, এবং `finally`

### ১.১ `try` ব্লক
- `try` ব্লকটি এমন একটি কোড ব্লক যা আপনি পরীক্ষা করতে চান যে এটি কোনো ত্রুটি তৈরি করবে কিনা।
- যদি `try` ব্লকটির মধ্যে কোনো ত্রুটি ঘটে, তাহলে ত্রুটি ক্যাচ করার জন্য `catch` ব্লক ব্যবহৃত হবে।

### ১.২ `catch` ব্লক
- `catch` ব্লকটি `try` ব্লকের মধ্যে কোনো ত্রুটি ঘটলে সেই ত্রুটিকে ধরতে এবং প্রক্রিয়া করতে ব্যবহৃত হয়।

### ১.৩ `finally` ব্লক
- `finally` ব্লকটি সবসময় চলে, এটি `try` এবং `catch` ব্লক সম্পন্ন হওয়ার পরেও চলে। এটি আপনি এমন কাজের জন্য ব্যবহার করতে পারেন যা সবসময় শেষ হওয়া উচিত (যেমন ফাইল বন্ধ করা, রিসোর্স মুক্ত করা, ইত্যাদি)।

### ১.৪ `try`, `catch`, এবং `finally` এর উদাহরণ:
```js
try {
  let result = 10 / 0; // এখানে বিভাজন অপারেশন হবে
  console.log("এই কোডটি চালানো হবে না।");
} catch (error) {
  console.log("ত্রুটি: ", error);  // এখানে ত্রুটি ধরা হবে
} finally {
  console.log("এই ব্লকটি সবসময় চলবে, ত্রুটি হোক বা না হোক।");
}
```



ত্রুটি:  Division by zero
এই ব্লকটি সবসময় চলবে, ত্রুটি হোক বা না হোক।



## ২. কাস্টম ত্রুটি (Throwing Custom Errors)

### ২.১ কাস্টম ত্রুটি কি?
- আপনি যখন নিজস্ব ত্রুটি তৈরি করতে চান তখন throw কিওয়ার্ড ব্যবহার করতে পারেন। এটি সাধারণত ত্রুটি মেসেজ বা কাস্টম ত্রুটি অবজেক্ট পাঠাতে ব্যবহৃত হয়।
### ২.২ কাস্টম ত্রুটি তৈরি করা:
```js
function checkAge(age) {
  if (age < 18) {
    throw new Error("আপনার বয়স ১৮ বছরের বেশি হতে হবে");
  } else {
    return "আপনি প্রাপ্তবয়স্ক";
  }
}

try {
  console.log(checkAge(16));  // এই ক্ষেত্রে ত্রুটি হবে
} catch (error) {
  console.log("ত্রুটি: ", error.message);  // কাস্টম ত্রুটি মেসেজ দেখানো হবে
}
```


ত্রুটি:  আপনার বয়স ১৮ বছরের বেশি হতে হবে


### ২.৩ কাস্টম ত্রুটির উদ্দেশ্য:
- যখন আপনি এমন পরিস্থিতি চিহ্নিত করতে চান যা প্রাকৃতিক বা স্বাভাবিক ত্রুটি নয়, তবে কিছু নির্দিষ্ট শর্ত বা নিয়মের জন্য তা হতে পারে।
- কাস্টম ত্রুটির মাধ্যমে আপনি ত্রুটির ধরন এবং সেগুলির সাথে সম্পর্কিত মেসেজগুলিকে কাস্টমাইজ করতে পারেন, যা আপনার কোডের কার্যকারিতা বুঝতে সাহায্য করে।


## উপসংহার:
- try, catch, এবং finally ব্লক ব্যবহার করে আপনি আপনার কোডে ত্রুটি হ্যান্ডলিং এবং ত্রুটির মধ্যে গতি নিয়ন্ত্রণ করতে পারেন।
- throw কিওয়ার্ড ব্যবহার করে আপনি নিজস্ব কাস্টম ত্রুটি তৈরি করতে পারেন এবং সেগুলির মাধ্যমে প্রোগ্রামিক্যালি ত্রুটি পরিচালনা করতে পারেন।





# প্রমিস (Promises) এবং অ্যাসিনক্রোনাস/অওয়েট (Async/Await)

## ১. প্রমিস (Promises) 

### ১.১ প্রমিস কি?
- প্রমিস একটি জাভাস্ক্রিপ্ট অবজেক্ট যা ভবিষ্যতে একটি ফলাফল প্রদান করবে। এটি মূলত একটি অ্যাসিনক্রোনাস অপারেশন বা ডেটা গ্রহণের প্রতিশ্রুতি (promise) ধারণ করে, যা নির্দিষ্ট সময়ে পূর্ণ (fulfilled) বা বাতিল (rejected) হতে পারে। প্রমিস ৩টি স্টেট হতে পারে:
  1. `pending` - প্রমিস এখনও সম্পূর্ণ হয়নি।
  2. `fulfilled` - প্রমিস সফলভাবে সম্পন্ন হয়েছে এবং একটি ফলাফল রয়েছে।
  3. `rejected` - প্রমিস ব্যর্থ হয়েছে এবং ত্রুটি বা সমস্যা সৃষ্টি হয়েছে।

### ১.২ প্রমিস কিভাবে কাজ করে?
- প্রমিস তৈরি করতে `new Promise()` কন্সট্রাক্টর ব্যবহার করতে হয়, যেখানে একটি এক্সিকিউটর ফাংশন থাকে যা দুইটি আর্গুমেন্ট গ্রহণ করে: `resolve` এবং `reject`। 
- `resolve` ব্যবহার করা হয় সফল অপারেশন শেষে প্রমিসকে পূর্ণ করতে, আর `reject` ব্যর্থ অপারেশন শেষে প্রমিসকে বাতিল করতে।

```js
let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve("প্রমিস সফলভাবে পূর্ণ হয়েছে!");
  } else {
    reject("প্রমিস ব্যর্থ হয়েছে!");
  }
});
```
### ১.৩ প্রমিস ব্যবহার করার সময়:
- প্রমিস ব্যবহার করা হয় যখন আমরা এমন কিছু কাজ করতে চাই যা সময় নেয়, যেমন API কল, ডেটাবেজ অপারেশন, ফাইল সিস্টেমের সাথে কাজ করা, অথবা কোনো ধরনের স্লো প্রসেস (যেমন: ইউজার থেকে ইনপুট গ্রহণ)।

### ১.৪ প্রমিসের সাথে .then() এবং .catch() ব্যবহার:
- .then() - এটি ব্যবহার করে সফল প্রমিসের ফলাফল পাওয়া যায়।
- .catch() - এটি ব্যবহার করে প্রমিসে যদি কোনো সমস্যা হয়, তবে ত্রুটি (error) হ্যান্ডেল করা হয়।
```js
let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve("ডেটা লোড সফল হয়েছে");
  } else {
    reject("ডেটা লোডে ত্রুটি ঘটেছে");
  }
});

promise.then((result) => {
  console.log(result);  // Output: ডেটা লোড সফল হয়েছে
}).catch((error) => {
  console.log(error);   // Output: ডেটা লোডে ত্রুটি ঘটেছে
});
```
## ২. অ্যাসিনক্রোনাস/অওয়েট (Async/Await)

### ২.১ অ্যাসিনক্রোনাস/অওয়েট কি?
- async এবং await নতুন ফিচার যা ES7 এ অন্তর্ভুক্ত হয়েছে। এটি অ্যাসিনক্রোনাস কোডের কার্যপ্রণালী সহজ করে তোলে, যা কোডের পড়ার সুবিধা বাড়ায় এবং প্রমিস ব্যবহারকারীদের জন্য আরো স্বাভাবিক কোড লেখার সুযোগ দেয়।
- async ফাংশন অ্যাসিনক্রোনাস কোড লিখতে ব্যবহৃত হয় এবং এটি একটি প্রমিস রিটার্ন করে।
- await ব্যবহার করা হয় async ফাংশনের মধ্যে, যেটি একটি প্রমিসের সম্পন্ন হওয়ার জন্য অপেক্ষা করে।

### ২.২ async ফাংশন:
- async ফাংশন যখন কল করা হয়, তখন এটি একটি প্রমিস রিটার্ন করে, এমনকি যদি ফাংশনের মধ্যে return ব্যবহার না হয়।
- async ফাংশন ব্যবহার করলে আপনি খুব সহজে অ্যাসিনক্রোনাস কোড পরিচালনা করতে পারবেন।
```js
async function fetchData() {
  return "ডেটা লোড হচ্ছে...";
}

fetchData().then(result => console.log(result)); // Output: ডেটা লোড হচ্ছে...
```
### ২.৩ await ব্যবহার:
- await কেবলমাত্র async ফাংশনের ভিতরে ব্যবহার করা যায়। এটি একটি প্রমিসের পরবর্তী ফলাফল পাওয়ার জন্য অপেক্ষা করে এবং প্রমিসটি পূর্ণ হলে এর মান রিটার্ন করে।
- await ব্যবহার করলে কোডটি সিঙ্ক্রোনাসভাবে চলবে, যার ফলে কোডের পড়া সহজ হবে এবং কমপ্লেক্সিটির পরিমাণ কমবে।
```js
async function fetchData() {
  let response = await fetch('https://jsonplaceholder.typicode.com/posts');
  let data = await response.json();
  console.log(data);
}

fetchData(); // এটি ডেটা লোড করে এবং কনসোল লগে প্রিন্ট করবে।
```
### ২.৪ async এবং await এর সুবিধা:
- কোড আরো পরিষ্কার ও সহজে পড়া যায়।
- প্রমিসের .then() চেইনিং ব্যবহার না করে আমরা কোডকে সহজ এবং সিঙ্ক্রোনাস স্টাইলে লিখতে পারি।
- প্রমিসের ত্রুটি হ্যান্ডলিং আরো সহজ হয়।

### ২.৫ অ্যাসিনক্রোনাস/অওয়েট ব্যবহার করার সময়:
- যখন আপনাকে অ্যাসিনক্রোনাস কাজ সম্পন্ন করার জন্য অপেক্ষা করতে হয়, যেমন API কল, ডেটা লোড করা বা ডেটাবেজ অপারেশন করা, তখন async/await অত্যন্ত কার্যকরী।
```js
async function loadData() {
  try {
    let response = await fetch('https://jsonplaceholder.typicode.com/posts');
    let data = await response.json();
    console.log(data); // Success: এটি ডেটা কনসোল লগে প্রিন্ট করবে
  } catch (error) {
    console.log("Error:", error); // Error handling: যদি কিছু ভুল হয়।
  }
}

loadData(); // এটি ডেটা লোড করার জন্য ফাংশন কল
```
## ৩. প্রমিস এবং অ্যাসিনক্রোনাস/অওয়েট এর তুলনা:
- প্রমিসে .then() এবং .catch() চেইনিং ব্যবহার করতে হয়, যা কিছু ক্ষেত্রে কোডকে কমপ্লেক্স করে তোলে।
- async/await স্টাইল সাধারণত প্রমিসের চেয়ে পড়তে সহজ এবং সিঙ্ক্রোনাস কোডের মতো কাজ করে।

### ৩.১ প্রমিসের চেইনিং:
```js
let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve("ডেটা লোড সফল!");
  } else {
    reject("ডেটা লোডে সমস্যা!");
  }
});

promise
  .then(result => {
    console.log(result); // Output: ডেটা লোড সফল!
  })
  .catch(error => {
    console.log(error);  // Output: ডেটা লোডে সমস্যা!
  });
```
### ৩.২ async/await এর সাহায্যে একই কোড:
```js
async function loadData() {
  try {
    let result = await new Promise((resolve, reject) => {
      let success = true;
      if (success) {
        resolve("ডেটা লোড সফল!");
      } else {
        reject("ডেটা লোডে সমস্যা!");
      }
    });
    console.log(result);  // Output: ডেটা লোড সফল!
  } catch (error) {
    console.log(error);   // Output: ডেটা লোডে সমস্যা!
  }
}

loadData();
```

## ৪. উপসংহার:
- প্রমিস অ্যাসিনক্রোনাস কোড পরিচালনা করার একটি শক্তিশালী পদ্ধতি, তবে async/await এর মাধ্যমে কোড লেখা অনেক সহজ এবং পরিষ্কার হয়।
- async/await কোডে ত্রুটি হ্যান্ডলিং সহজ করে এবং প্রমিসের .then() এবং .catch() ব্যবহার না করে কোডকে আরো সিঙ্ক্রোনাস স্টাইলে লেখা সম্ভব হয়।
- যখন আপনার অ্যাসিনক্রোনাস অপারেশন থাকে (যেমন API কল), তখন আপনি সহজেই async/await ব্যবহার করতে পারেন যা কোডকে পরিস্কার এবং বেশি রিয়ুসেবল করে তোলে।



# ফাংশনাল প্রোগ্রামিং (Functional Programming)


## ১. হাইয়ার-অর্ডার ফাংশন (Higher-order Functions)

### ১.১ হাইয়ার-অর্ডার ফাংশন কি?
- হাইয়ার-অর্ডার ফাংশন এমন ফাংশন যেটি অন্য একটি ফাংশনকে আর্গুমেন্ট হিসেবে গ্রহণ করতে পারে অথবা একটি ফাংশন রিটার্ন করতে পারে।
- এই ধরনের ফাংশন ফাংশনাল প্রোগ্রামিংয়ে অত্যন্ত গুরুত্বপূর্ণ, কারণ এটি অন্য ফাংশনগুলির সাথে কাজ করতে এবং তাদের প্রক্রিয়াকরণ করতে সক্ষম।

### ১.২ হাইয়ার-অর্ডার ফাংশনের উদাহরণ:
- উদাহরণস্বরূপ, একটি ফাংশন যেটি অন্য একটি ফাংশনকে আর্গুমেন্ট হিসেবে গ্রহণ করে এবং একটি নতুন ফাংশন রিটার্ন করে:

```js
function greet(name) {
  return `হ্যালো, ${name}!`;
}

function executeFunction(func, value) {
  return func(value);
}

console.log(executeFunction(greet, "রাকিব")); // Output: হ্যালো, রাকিব!
```
### ১.৩ কবে হাইয়ার-অর্ডার ফাংশন ব্যবহার করবেন:
- যখন আপনাকে একটি ফাংশনকে অন্য ফাংশনের আর্গুমেন্ট হিসেবে পাস করতে হয়।
- ফাংশনাল প্রোগ্রামিংয়ে, হাইয়ার-অর্ডার ফাংশনটি ডাটা ট্রান্সফর্মেশন বা কমপ্লেক্স অপারেশন সম্পাদন করতে ব্যবহার করা হয়।



## ২. পিউর ফাংশন (Pure Functions)

### ২.১ পিউর ফাংশন কি?
- পিউর ফাংশন হলো এমন একটি ফাংশন যা:
1. একই ইনপুটে সর্বদা একই আউটপুট দেয়।
2. এটি কোনো বাহ্যিক (external) অবস্থা পরিবর্তন বা প্রভাবিত করে না।
- এর মানে হলো, পিউর ফাংশন কোনো গ্লোবাল স্টেট বা ভ্যারিয়েবল পরিবর্তন করে না, বরং ইনপুট অনুযায়ী আউটপুট প্রদান করে।

### ২.২ পিউর ফাংশনের উদাহরণ:
```js
function add(a, b) {
  return a + b;  // এই ফাংশনটি পিউর কারণ এটি একই ইনপুটে একই আউটপুট প্রদান করবে।
}

console.log(add(2, 3));  // Output: 5
```
### ২.৩ কবে পিউর ফাংশন ব্যবহার করবেন:
- যখন আপনাকে এমন ফাংশন তৈরি করতে হয় যা predictable এবং নির্ভরযোগ্য, অর্থাৎ একই ইনপুটে প্রতিবার একই আউটপুট দিবে।
- এটি কোডের পরীক্ষণ (testing) এবং ডিবাগিং সহজ করে।



## ৩. ক্লোজার (Closures)

### ৩.১ ক্লোজার কি?
- ক্লোজার একটি ফাংশন যা তার আউটপুট প্রদান করতে পারে এবং এই ফাংশনটি একটি ভ্যারিয়েবল (যে ভ্যারিয়েবলটি বাইরের ফাংশনে ডিফাইন করা থাকে) অ্যাক্সেস করতে পারে যা তার আউটপুট নির্ধারণের জন্য ব্যবহৃত হয়।
- ক্লোজারগুলি বাইরের ফাংশনের স্কোপে থাকা ভ্যারিয়েবলগুলিকে মনে রাখে।
### ৩.২ ক্লোজারের উদাহরণ:
```js
function outer() {
  let counter = 0;
  return function inner() {
    counter++;
    console.log(counter);  // ক্লোজার, কারণ inner ফাংশন বাইরের counter ভ্যারিয়েবলকে অ্যাক্সেস করতে পারছে।
  };
}

const count = outer();
count();  // Output: 1
count();  // Output: 2
```

### ৩.৩ কবে ক্লোজার ব্যবহার করবেন:
- যখন আপনাকে একটি ফাংশন তৈরি করতে হবে যা বাইরের ফাংশনের ভ্যারিয়েবলগুলির অবস্থা সংরক্ষণ করবে, এমনকি বাইরের ফাংশনটি চলে যাওয়ার পরেও।
- এটি প্রাইভেট ভ্যারিয়েবল সংরক্ষণের জন্য ব্যবহৃত হয়।



## ৪. কারি (Currying)

### ৪.১ কারি কি?
- কারি এমন একটি পদ্ধতি যা ফাংশনের একাধিক আর্গুমেন্টকে একে একে গ্রহণ করতে সক্ষম করে, অর্থাৎ, এটি ফাংশনকে একাধিক আর্গুমেন্ট গ্রহণ করার পরিবর্তে একে একে আর্গুমেন্ট গ্রহণ করতে বাধ্য করে।
- এই ফাংশনালিটি অনেক ধরনের কাস্টমাইজেশন এবং রিইউজেবল কোড তৈরি করতে সাহায্য করে।
### ৪.২ কারির উদাহরণ:
```js
function multiply(a) {
  return function(b) {
    return a * b;
  };
}

const multiplyBy2 = multiply(2);  // multiply(2) কাকে ব্যবহার করা হয়
console.log(multiplyBy2(5)); // Output: 10
```
### ৪.৩ কবে কারি ব্যবহার করবেন:
- যখন আপনি একাধিক আর্গুমেন্ট প্রক্রিয়া করতে চান এবং আপনি ফাংশনটিকে পুনঃব্যবহারযোগ্য এবং কাস্টমাইজযোগ্য করতে চান।


## ৫. রিকার্সন (Recursion)
### ৫.১ রিকার্সন কি?
- রিকার্সন হল একটি ফাংশন যা নিজেই কল করে। এটি তখনই স্টপ হয় যখন একটি নির্দিষ্ট শর্ত পূর্ণ হয়।
- রিকার্সনকে সাধারণত পুনরাবৃত্তি কাজগুলি সমাধান করার জন্য ব্যবহার করা হয়, যেমন ফ্যাক্টোরিয়াল গণনা, ফিবোনাচ্চি সিরিজ বা গাছের (trees) মতো ডেটা স্ট্রাকচার ট্রাভার্সাল।
### ৫.২ রিকার্সনের উদাহরণ:
```js
function factorial(n) {
  if (n === 0) {
    return 1;
  }
  return n * factorial(n - 1);  // ফাংশন নিজেই নিজেকে কল করছে
}

console.log(factorial(5));  // Output: 120
```

### ৫.৩ কবে রিকার্সন ব্যবহার করবেন:
- যখন আপনি এমন সমস্যা সমাধান করছেন যা উপসমূহ (sub-problems) হতে পারে এবং একটি উপসম্ভাব্য সমাধান আবার মূল সমস্যায় ফিট হতে পারে।
- যেমন গাণিতিক গণনা, ডেটা ট্রাভার্সাল এবং এমনকি ফাইল সিস্টেম পরিচালনা।
## উপসংহার:
- হাইয়ার-অর্ডার ফাংশন আপনার ফাংশনগুলিকে আরো শক্তিশালী এবং নমনীয় করে তোলে, ফাংশন পাস এবং ফেরত দেওয়ার মাধ্যমে।
- পিউর ফাংশন কোডকে সহজ এবং নির্ভরযোগ্য করে তোলে।
- ক্লোজার আপনাকে ভিতরের ফাংশনের মাধ্যমে বাইরের স্কোপের ভ্যারিয়েবল সংরক্ষণ করতে সাহায্য করে।
- কারি ফাংশনগুলির আর্গুমেন্টকে একে একে গ্রহণ করতে এবং ফাংশন পুনঃব্যবহারযোগ্য করতে সাহায্য করে।
- রিকার্সন উপসমূহ সমাধান করার জন্য ব্যবহৃত হয় এবং কমপ্লেক্স প্রব্লেমগুলোকে ছোট ছোট টুকরোয় ভেঙে দেয়।

